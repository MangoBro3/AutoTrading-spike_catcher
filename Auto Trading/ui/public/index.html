<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Auto Trading Dashboard</title>
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;background:#0f1115;color:#e9edf1;margin:0;padding:16px}
    h1{margin:0;font-size:22px}
    h2{margin:0 0 10px;font-size:17px}
    .muted{color:#9aa4b2;font-size:12px}
    .ok{color:#47d16c}.warn{color:#ffca5f}.bad{color:#ff6b6b}
    .grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(320px,1fr));gap:12px;margin-top:12px}
    .card{background:#161a22;border:1px solid #252b36;border-radius:10px;padding:12px}
    .banner{display:none;margin:12px 0 0;padding:10px 12px;border-radius:8px;font-weight:700}
    .banner.show{display:block}
    .banner.danger{background:#4a1318;border:1px solid #a8323d;color:#ffd7dc}
    .btn{background:#243047;border:1px solid #33425f;color:#e9edf1;padding:6px 10px;border-radius:6px;cursor:pointer}
    .btn:disabled{opacity:.5;cursor:not-allowed}
    .btn-danger{background:#4a1f24;border-color:#7a2f39;color:#ffd7dc}
    .inline{display:flex;align-items:center;gap:8px;flex-wrap:wrap;margin-top:8px}
    .spinner{display:inline-block;width:12px;height:12px;border:2px solid #5d6a81;border-top-color:#e9edf1;border-radius:50%;animation:spin .7s linear infinite;vertical-align:-2px}
    @keyframes spin{to{transform:rotate(360deg)}}
    input[type="text"]{flex:1;background:#111722;border:1px solid #2a3342;color:#e9edf1;border-radius:6px;padding:6px}
    table{width:100%;border-collapse:collapse;font-size:13px}
    th,td{padding:7px;border-bottom:1px solid #262d38;text-align:left;vertical-align:top}
    code{background:#1f2530;padding:1px 5px;border-radius:6px}

    .pill{display:inline-flex;align-items:center;padding:4px 10px;border-radius:999px;font-size:12px;font-weight:700;border:1px solid transparent}
    .pill-stop{background:#3a2024;color:#ffb7c0;border-color:#6f303a}
    .pill-wait{background:#3d3320;color:#ffd98e;border-color:#72603b}
    .pill-run{background:#1f3a2a;color:#9ff1bc;border-color:#356a4a}

    .switch-wrap{display:flex;align-items:center;gap:10px;margin:8px 0}
    .switch{position:relative;display:inline-block;width:52px;height:30px}
    .switch input{opacity:0;width:0;height:0}
    .slider{position:absolute;cursor:pointer;top:0;left:0;right:0;bottom:0;background:#394253;transition:.2s;border-radius:999px}
    .slider:before{position:absolute;content:"";height:22px;width:22px;left:4px;bottom:4px;background:white;transition:.2s;border-radius:50%}
    input:checked + .slider{background:#2e6f43}
    input:checked + .slider:before{transform:translateX(22px)}
    input:disabled + .slider{opacity:.5;cursor:not-allowed}

    .modal{position:fixed;inset:0;background:rgba(0,0,0,.55);display:none;align-items:center;justify-content:center;z-index:50}
    .modal.show{display:flex}
    .modal-card{width:min(460px,92vw);background:#161a22;border:1px solid #2f3745;border-radius:10px;padding:14px}
    .modal-actions{display:flex;justify-content:flex-end;gap:8px;margin-top:12px}
  </style>
</head>
<body>
  <h1>Auto Trading Dashboard</h1>
  <div class="muted" id="ts">loading...</div>
  <div class="inline">
    <button id="refreshConnBtn" class="btn">연결 상태 새로고침</button>
    <span id="refreshConnState" class="muted">수동 갱신: -</span>
  </div>
  <div id="stopBanner" class="banner danger"></div>

  <div class="grid">
    <div class="card">
      <h2>Worker Safety / Traffic Light</h2>
      <div id="worker"></div>
    </div>

    <div class="card">
      <h2>Auto Trading ON/OFF</h2>
      <div class="muted">LIVE 2단 확인 유지: ON 클릭 → 승인 모달 확인 후 시작 확정</div>
      <div style="margin-top:8px">현재 상태: <span id="controlPhaseBadge" class="pill pill-stop">STOPPED</span></div>
      <div class="switch-wrap">
        <label class="switch" title="Auto Trading Toggle">
          <input id="autoToggle" type="checkbox" />
          <span class="slider"></span>
        </label>
        <span id="autoToggleLabel" style="font-weight:700">OFF</span>
      </div>
      <div id="controlStatus" class="muted">대기중</div>
    </div>

    <div class="card">
      <h2>Panic 안전장치</h2>
      <div class="muted">1) 슬라이더를 100으로 이동 2) HOLD 2초 유지</div>
      <div style="margin-top:8px">
        <input id="panicSlider" type="range" min="0" max="100" step="1" value="0" style="width:100%" />
        <div class="muted">value: <span id="panicValue">0</span></div>
      </div>
      <button id="panicHoldBtn" class="btn" style="margin-top:8px">HOLD TO PANIC</button>
      <div id="panicStatus" class="muted" style="margin-top:8px">대기중</div>
    </div>

    <div class="card">
      <h2>Orders 취소</h2>
      <div class="muted">주문 ID 입력 후 Cancel 클릭</div>
      <div style="margin-top:8px;display:flex;gap:8px;align-items:center">
        <input id="orderIdInput" type="text" placeholder="ORD-001" />
        <button id="orderCancelBtn" class="btn">Cancel Order</button>
      </div>
      <div id="orderStatus" class="muted" style="margin-top:8px">대기중</div>
    </div>
  </div>

  <div class="card" style="margin-top:12px">
    <h2>계좌 / 포지션 / PnL</h2>
    <div id="account"></div>
    <div id="positions" style="margin-top:10px"></div>
  </div>

  <div id="confirmModal" class="modal">
    <div class="modal-card">
      <h2 style="margin-bottom:8px">2단 확인</h2>
      <div id="confirmModalText" class="muted" style="font-size:13px"></div>
      <div class="modal-actions">
        <button id="confirmModalCancel" class="btn">취소</button>
        <button id="confirmModalApprove" class="btn btn-danger">승인 후 진행</button>
      </div>
    </div>
  </div>

<script>
const $ = (id)=>document.getElementById(id);
function esc(s){return String(s??'').replace(/[<>&]/g,m=>({'<':'&lt;','>':'&gt;','&':'&amp;'}[m]))}

function val(obj, keys, fallback='-') {
  for (const k of keys) {
    const v = obj?.[k];
    if (v !== undefined && v !== null && v !== '') return v;
  }
  return fallback;
}

let latestOverview = null;
let controlBusy = false;
let syncingToggle = false;
let manualRefreshBusy = false;
let lastManualRefreshAt = null;
let lastManualRefreshError = '';

function setManualRefreshState() {
  const btn = $('refreshConnBtn');
  const label = $('refreshConnState');
  btn.disabled = manualRefreshBusy;
  btn.innerHTML = manualRefreshBusy ? '<span class="spinner"></span> 새로고침 중...' : '연결 상태 새로고침';
  const timeText = lastManualRefreshAt ? new Date(lastManualRefreshAt).toLocaleTimeString() : '-';
  label.textContent = lastManualRefreshError ? `수동 갱신 실패: ${lastManualRefreshError}` : `수동 갱신: ${timeText}`;
}

async function fetchJson(url) {
  const r = await fetch(url);
  const j = await r.json();
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return j;
}

function normalizeWorkerPayload(payload) {
  if (!payload || typeof payload !== 'object') return null;
  if (payload.worker && typeof payload.worker === 'object') return payload.worker;
  if (payload.result && payload.result.worker && typeof payload.result.worker === 'object') return payload.result.worker;
  if (payload.state || payload.trafficLight || payload.connected !== undefined) return payload;
  return null;
}

function phaseFromOverview(data) {
  const phaseRaw = data?.worker?.state?.phase || data?.worker?.phase || data?.phase || 'STOPPED';
  return String(phaseRaw || 'STOPPED').toUpperCase();
}

function isAutoOnByPhase(phase) {
  return phase === 'RUNNING' || phase === 'WAITING_OPERATOR';
}

function phaseBadgeClass(phase) {
  if (phase === 'RUNNING') return 'pill pill-run';
  if (phase === 'WAITING_OPERATOR') return 'pill pill-wait';
  return 'pill pill-stop';
}

function syncToggleUI(phase) {
  syncingToggle = true;
  const checked = isAutoOnByPhase(phase);
  $('autoToggle').checked = checked;
  $('autoToggle').disabled = controlBusy;
  $('autoToggleLabel').textContent = checked ? 'ON' : 'OFF';
  const badge = $('controlPhaseBadge');
  badge.className = phaseBadgeClass(phase);
  badge.textContent = phase;
  syncingToggle = false;
}

function render(data){
  latestOverview = data;
  $('ts').textContent = `updated: ${new Date(data.now || Date.now()).toLocaleString()}${data.sourceOk?'':'  |  openclaw json source unavailable'}`;

  const worker = data.worker || {};
  const light = String(worker.trafficLight || 'DISCONNECTED').toUpperCase();
  const lightClass = light === 'GREEN' ? 'ok' : (light === 'YELLOW' ? 'warn' : 'bad');
  $('worker').innerHTML = `<div><b>traffic light</b>: <b class="${lightClass}">${esc(light)}</b></div>
    <div><b>connected</b>: ${worker.connected===true?'<span class="ok">yes</span>':'<span class="bad">no</span>'}</div>
    <div><b>stop all</b>: ${worker.stopAll?'<span class="bad">ACTIVE</span>':'<span class="ok">off</span>'}</div>
    <div><b>updated</b>: ${worker.ts?esc(new Date(worker.ts).toLocaleTimeString()):'-'}</div>`;

  const banner = $('stopBanner');
  if (worker.stopAll) {
    banner.className = 'banner danger show';
    banner.textContent = worker.banner || `${light}: 전체 중단`;
  } else {
    banner.className = 'banner danger';
    banner.textContent = '';
  }

  const phase = phaseFromOverview(data);
  syncToggleUI(phase);

  const acc = data.account || data.balance || data.portfolio || data.trading?.account || {};
  const positions = data.positions || data.trading?.positions || [];
  const pnlSource = data.pnl || data.trading?.pnl || {};

  const equity = val(acc, ['equity','totalEquity','netAsset']);
  const available = val(acc, ['available','cash','availableBalance']);
  const margin = val(acc, ['margin','usedMargin']);
  const unrealized = val(pnlSource, ['unrealized','unrealizedPnl','uPnL']);
  const realized = val(pnlSource, ['realized','realizedPnl']);
  const daily = val(pnlSource, ['daily','dailyPnl','today']);

  $('account').innerHTML = `<table><tbody>
    <tr><th>Equity</th><td>${esc(equity)}</td><th>Available</th><td>${esc(available)}</td></tr>
    <tr><th>Margin</th><td>${esc(margin)}</td><th>Daily PnL</th><td>${esc(daily)}</td></tr>
    <tr><th>Unrealized PnL</th><td>${esc(unrealized)}</td><th>Realized PnL</th><td>${esc(realized)}</td></tr>
  </tbody></table>`;

  const rows = Array.isArray(positions) ? positions : (Array.isArray(positions.list) ? positions.list : []);
  if (!rows.length) {
    $('positions').innerHTML = '<div class="muted">포지션 없음</div>';
  } else {
    $('positions').innerHTML = `<table><thead><tr><th>Symbol</th><th>Side</th><th>Qty</th><th>Entry</th><th>Mark</th><th>PnL</th></tr></thead><tbody>`+
      rows.slice(0, 20).map(p=>`<tr>
        <td>${esc(val(p,['symbol','ticker']))}</td>
        <td>${esc(val(p,['side','direction']))}</td>
        <td>${esc(val(p,['qty','size','positionAmt']))}</td>
        <td>${esc(val(p,['entry','entryPrice','avgPrice']))}</td>
        <td>${esc(val(p,['mark','markPrice','lastPrice']))}</td>
        <td>${esc(val(p,['pnl','unrealizedPnl','uPnL']))}</td>
      </tr>`).join('')+
      `</tbody></table>`;
  }
}

async function postControl(action, body){
  const r = await fetch(`/api/worker/control/${action}`, {
    method: 'POST',
    headers: {'content-type':'application/json'},
    body: JSON.stringify(body || {}),
  });
  const j = await r.json();
  if(!r.ok || j.ok===false) throw new Error(j.error || `control_failed:${action}`);
  if (j?.result?.ok === false) {
    throw new Error(j?.result?.detail || j?.result?.error || `worker_control_failed:${action}`);
  }
  return j;
}

function openConfirmModal(text) {
  return new Promise((resolve) => {
    const modal = $('confirmModal');
    const approve = $('confirmModalApprove');
    const cancel = $('confirmModalCancel');
    $('confirmModalText').textContent = text;
    modal.classList.add('show');

    const done = (ok) => {
      modal.classList.remove('show');
      approve.removeEventListener('click', onApprove);
      cancel.removeEventListener('click', onCancel);
      resolve(ok);
    };
    const onApprove = () => done(true);
    const onCancel = () => done(false);

    approve.addEventListener('click', onApprove);
    cancel.addEventListener('click', onCancel);
  });
}

async function runWithControlBusy(fn) {
  if (controlBusy) return;
  controlBusy = true;
  $('autoToggle').disabled = true;
  try {
    await fn();
  } finally {
    controlBusy = false;
    const currentPhase = phaseFromOverview(latestOverview || {});
    syncToggleUI(currentPhase);
  }
}

async function handleTurnOn() {
  await runWithControlBusy(async () => {
    const phase = phaseFromOverview(latestOverview || {});
    let expectedPhrase = latestOverview?.worker?.state?.pending?.expected_phrase || null;

    if (phase === 'STOPPED') {
      $('controlStatus').textContent = '시작 요청 중...';
      const started = await postControl('start', {});
      expectedPhrase = started?.result?.expected_phrase || expectedPhrase;
      if (!expectedPhrase) throw new Error('expected_phrase 누락');
    } else if (phase === 'WAITING_OPERATOR') {
      if (!expectedPhrase) throw new Error('pending expected_phrase 없음');
    } else if (phase === 'RUNNING') {
      $('controlStatus').textContent = '이미 RUNNING 상태입니다.';
      await tick();
      return;
    } else {
      throw new Error(`지원하지 않는 phase: ${phase}`);
    }

    const approved = await openConfirmModal('LIVE 2단 확인: 시작을 승인하면 backend expected_phrase로 최종 confirm을 수행합니다.');
    if (!approved) {
      $('controlStatus').textContent = '취소됨: 승인 전 단계에서 중단';
      await tick();
      return;
    }

    $('controlStatus').textContent = '승인됨: 시작 확정 중...';
    await postControl('confirm', { phrase: expectedPhrase });
    $('controlStatus').textContent = 'Auto Trading ON (RUNNING)';
    await tick();
  });
}

async function handleTurnOff() {
  await runWithControlBusy(async () => {
    $('controlStatus').textContent = '정지 요청 중...';
    await postControl('stop', {});
    $('controlStatus').textContent = 'Auto Trading OFF (STOPPED)';
    await tick();
  });
}

$('autoToggle').addEventListener('change', async (ev) => {
  if (syncingToggle) return;
  try {
    if (ev.target.checked) {
      await handleTurnOn();
    } else {
      await handleTurnOff();
    }
  } catch (e) {
    $('controlStatus').textContent = `실패: ${e.message}`;
    await tick();
  }
});

const panicSlider = $('panicSlider');
const panicValue = $('panicValue');
const panicStatus = $('panicStatus');
const panicHoldBtn = $('panicHoldBtn');
let holdTimer = null;
let holdStart = 0;

panicSlider.addEventListener('input', ()=>{ panicValue.textContent = panicSlider.value; });

panicHoldBtn.addEventListener('mousedown', ()=>{
  if (Number(panicSlider.value) < 100) {
    panicStatus.textContent = '실패: 슬라이더를 100으로 올리세요';
    return;
  }
  holdStart = Date.now();
  panicStatus.textContent = '홀드 중...';
  holdTimer = setTimeout(async ()=>{
    try {
      const out = await postControl('panic', { armed: true, holdMs: Date.now()-holdStart, slider: Number(panicSlider.value) });
      panicStatus.textContent = `PANIC 실행됨 (${out?.result?.status || 'ok'})`;
      await tick();
    } catch (e) {
      panicStatus.textContent = `실패: ${e.message}`;
    }
  }, 2000);
});

['mouseup','mouseleave'].forEach((ev)=> panicHoldBtn.addEventListener(ev, ()=>{
  if (holdTimer) {
    clearTimeout(holdTimer);
    holdTimer = null;
    if (Date.now() - holdStart < 2000) panicStatus.textContent = '취소됨: 2초 이상 홀드 필요';
  }
}));

$('orderCancelBtn').addEventListener('click', async ()=>{
  const orderId = String($('orderIdInput').value || '').trim();
  if (!orderId) {
    $('orderStatus').textContent = '실패: orderId 입력 필요';
    return;
  }
  try {
    const out = await postControl('cancel-order', { orderId });
    $('orderStatus').textContent = `취소 요청 성공: ${out?.result?.orderId || orderId} (${out?.result?.status || 'ok'})`;
    await tick();
  } catch (e) {
    $('orderStatus').textContent = `실패: ${e.message}`;
  }
});

$('refreshConnBtn').addEventListener('click', async () => {
  if (manualRefreshBusy) return;
  manualRefreshBusy = true;
  setManualRefreshState();
  try {
    const [workerPayload, overview] = await Promise.all([
      fetchJson('/api/worker'),
      fetchJson('/api/overview'),
    ]);
    const worker = normalizeWorkerPayload(workerPayload);
    if (worker) overview.worker = worker;
    render(overview);
    lastManualRefreshAt = Date.now();
    lastManualRefreshError = '';
  } catch (e) {
    lastManualRefreshError = e.message;
  } finally {
    manualRefreshBusy = false;
    setManualRefreshState();
  }
});

async function tick(){
  try{
    const j = await fetchJson('/api/overview');
    render(j);
  }catch(e){$('ts').textContent='fetch failed: '+e.message}
}

setManualRefreshState();
tick(); setInterval(tick, 1000);
</script>
</body>
</html>
